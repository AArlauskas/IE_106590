# Lab 3 description
## Lab 3.1

 - Created project with Spring Initializr.
 - Installed required dependencies (Spring Web, Thymeleaf, Spring Data JPA, H2database, and Validation).
 - Created packages to structure the project.
 - Added User model with fields specified in the tutorial, provided getters, setters and constructors. The User class was marked as Entity (so that JPA can initialize it in the project).
 - Created User repository interface with the extension of CrudRepository. This allows JPA to connect to the database and using the ORM map the database to objects by providing built in SQL statements.
 - Created a UsersController class to handle requests based on URL. It interacts with the usersRepository and redirects to the correct html Thymeleaf template.
 - Copied the html template pages from the example project repository as resources.
 - Tested the application.
 - Added support for phone number in the Model and the templates.
 

### Q&A for lab 3.1

 

 1_Q:  The “UserController” class gets an instance of “userRepository” through its constructor; how is this new repository instantiated?
 1_A: By using Spring Boot framework we can allow it work with beans. Beans are classes that can be managed by Spring Boot. This means that during the build process, Spring Boot finds all beans (Repositories, Services, Components , etc. are beans) and allows us to use Dependency injection with them. They are initialized automatically by Spring boot and can be injected to other beans either through constructors or using @Autowired annotation.
 
 2_Q: List the methods invoked in the “userRepository” object by the “UserController”. Where are these methods defined?
 2_A: FindById, save, delete, These methods are built in into CrudRepository interface. The implementation of these methods is done automatically through Spring Boot and JPA. It finds out which database is being used and using the driver, makes the correct SQL statements. 
 
3_Q: Where is the data being saved?
3_A: In this case, we are using H2 database, without specifying any configuration details. By default H2 database stores information in memory. This means, that every time the application is restarted the data that was put into database is lost

4_Q: Where is the rule for the “not empty” email address defined?
4_A: Line 19 in the "User" mode. @NotBlank(message = "Email is mandatory")

## Lab 3.2

 - Created the lab 3.2 project with Spring Initializr.
 - Added required dependencies (Spring Web, Spring Data JPA, MySQLdriver, DevTools and Validation).
 - Created packages to organize the code.
 - Created the employee entity marking it as @Entity. Provided the required columns marking them with @Column. The Id was marked as @Id and was set to auto-generate which is handled by the database.
 - Created @Repository interface for employees (EmployeeRepository) extending it with JpaRepository (CrudRepository with more built-in methods)
 - Created rest controller with the following methods: GET: getAllEmployees, getEmployeeById, getEmployeeByEmailAddress. POST: createEmployee. PUT: UpdateEmployee.
 - Started up Docker and ran this command to have an MySQL database running: `docker run --name mysql5 -e MYSQL_ROOT_PASSWORD=secret1 -e MYSQL_DATABASE=demo -e MYSQL_USER=demo -e MYSQL_PASSWORD=secret2 -p 33060:3306 -d mysql/mysql-server:5.7`
 - Tested out connection to the database with the Intelij's database tool.
 - Provided the parameters so that Spring Boot would know which database to use. Parameters are as follows: 

    spring.datasource.url=jdbc:mysql://127.0.0.1:33060/demo  
    spring.datasource.username=demo  
    spring.datasource.password=secret2  
    spring.jpa.database-platform=org.hibernate.dialect.MySQL5InnoDBDialect  
    spring.jpa.hibernate.ddl-auto=update

 - Tested out the application with the browser and postman to make sure that everything works as expected.

## Lab 3.3

 - Reformatted code from the previous lab of MovieQuotesApi to work with the persistent database.
 - Changed the definition of model classes by using Spring Boot JPA annotations. Provided Id witch is generated by the database. Defined simple columns. Also, separated the two classes and connected them with @OneToMany relationship (One show has many Quotes)
 - Created repositories for both classes
 - Added support for H2 file database
 - Changed the logic of QuotesService and ShowsService to respect the new rules imposed by JPA.
 - Changed up Dtos for more convenient requests and responses.
 - Removed all static data
 - Added @PostContstruct method to add initial data to the database after the project has started.
 - Changed up endpoints to better represent the API based on conventions.
 - Tested out the application that CRUD (Except for delete) works as intended.
 - Built the jar file by using `mvnw install` command.
 - Wrote Dockerfile based on the provided tutorial but changing Java version to 11. Dockerfile contents: `FROM openjdk:11
VOLUME /tmp
COPY target/moviequotesapi-0.0.1-SNAPSHOT.jar app.jar
ENTRYPOINT ["java","-jar","/app.jar"]`
 - Built the docker image by running: `docker build  -t myorg/myapp .`
 - Started the docker image by running: `docker run -p 8080:8080 myorg/myapp`
 - Tested out the docker application to make sure that everything works the same.

## Lab 3 Q&A

 1_Q. Explain the differences between the RestController and Controller components used in different parts of this lab.
 1_A: The  _@Controller_  annotations is used for traditional spring MVC framework Controller for long time.The  _@_**_RestController_**  annotation was introduced in Spring 4.0 to simplify the creation of  **RESTful**  web services.

The  **@RestController**  annotation in Spring MVC/Spring BOOT is nothing but a combination of @**Controller**  and @**ResponseBody**  annotation.

It was added into Spring 4.0 to make the development of  **RESTful**  Web Services in Spring framework easier.

If you know  **REST web  services** you know that the fundamental difference between a REST API and a web application.

That is the response from a  **web application**  is generally view (HTML + CSS) because they are intended for human viewers.

**REST API**  just returns data in form of JSON or XML because most of the REST clients are programs. This difference is also obvious in the  **@Controller**  and  **@RestController**  annotation.

 2_Q. Create a visualization of the Spring Boot layers (UML diagramor similar), displaying the key abstractions in the solution of 3.3, in particular: entities, repositories, services and REST controllers.
 2_A: Photo in repository.
  3_Q: Explain the annotations @Table, @Column, @Id found in the Employee entity.
 3_A: 
 - @Table is used to specify the table properties, usually the name of the table that should be used in the database to store the data.
 - @Column is used to provide or override default properties for a field. For example the column name to use for the column, or if it can be null or not.
 - @Id is used to specify which field is the PrimaryKey of the Table that is to be created. It is necessary in order for JPA to map the PrimaryKeys correctly.
 
 4_Q: Explain the use of the annotation @Autowired (in the Rest Controller class).
 4_A: @Autowired is used to mark the field to be automatically Dependency Injected by Spring Boot. This means that only one instance of the class is created and the full lifecycle of that object is handled by Spring Boot. This optimizes code and let's the programmer to not worry about the most optimal way of doing DI.

 
